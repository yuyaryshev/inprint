"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleFile = handleFile;
exports.callEmbeddedFeatures = callEmbeddedFeatures;
exports.doInprint = doInprint;
exports.expectFeature = expectFeature;
exports.run = run;
exports.writeFileSyncIfChanged = exports.usageNotice = exports.endPrefix = exports.startPrefix = exports.inprint_prefix = void 0;

var _json = _interopRequireDefault(require("json5"));

var _globby = _interopRequireDefault(require("globby"));

var _fs = require("fs");

var _path = require("path");

var _embeddedFeatures = require("./embeddedFeatures");

var _InprintOptions = require("./InprintOptions");

var _formatTypescript = require("./formatTypescript");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const inprint_prefix = "@" + "INPRINT";
exports.inprint_prefix = inprint_prefix;
const startPrefix = "_START";
exports.startPrefix = startPrefix;
const endPrefix = "_END";
exports.endPrefix = endPrefix;
const usageNotice = `
USAGE:

// ${inprint_prefix}_START {...any_json_params...}
// Generated code will go here
// ${inprint_prefix}_END
`;
exports.usageNotice = usageNotice;

const writeFileSyncIfChanged = (fileName, content) => {
  let current;

  try {
    current = (0, _fs.readFileSync)(fileName, "utf-8");
  } catch (e) {}

  if (current !== content) {
    (0, _fs.writeFileSync)(fileName, content, "utf-8");
    return true;
  }

  return false;
};

exports.writeFileSyncIfChanged = writeFileSyncIfChanged;

function handleFile(filePath, options) {
  const contentStr = (0, _fs.readFileSync)(filePath, "utf-8");
  if (!contentStr.includes(inprint_prefix)) return false;
  const [fileHeader, ...parts0] = contentStr.split(inprint_prefix);
  const parts = [];

  for (let i = 0; i < parts0.length; i += 2) {
    const s = parts0[i];

    if (!s.startsWith(startPrefix)) {
      console.error(`CODE00000001 INPRINT_ERROR No ${inprint_prefix}${startPrefix} in ${filePath}`);
      return false;
    }

    if (!parts0[i + 1].startsWith(endPrefix)) {
      console.error(`CODE00000002 INPRINT_ERROR No ${inprint_prefix}${endPrefix} in ${filePath}`);
    }

    try {
      const [header, ...middleParts] = s.split("\n");
      const lastPart = middleParts.pop();
      const paramsStr = header.substr(startPrefix.length).trim();
      const middle = middleParts.join("\n");
      const tail = lastPart + inprint_prefix + parts0[i + 1];

      const params = _objectSpread({
        content: middle,
        absolutePath: filePath
      }, _json.default.parse(paramsStr));

      parts.push({
        header,
        params,
        middle,
        tail,
        newMiddle: ""
      });
    } catch (e) {
      console.error(`CODE00000003 INPRINT_ERROR ${e.message} in ${filePath}`);
      return false;
    }
  }

  for (let part of parts) {
    try {
      part.newMiddle = doInprint(part.params, options);
    } catch (e) {
      part.newMiddle = `// INPRINT_FAILED because of exception:\n${e.message || "NO_ERROR_MESSAGE"}\\n${e.stack || "NO_STACK_TRACE"}`.split("\n").join("\n//     ");
    }
  }

  const newContent = (0, _formatTypescript.formatTypescript)(fileHeader + inprint_prefix + parts.map(p => `${p.header}\n${p.newMiddle}\n${p.tail}`).join(inprint_prefix), options.prettierOpts);
  writeFileSyncIfChanged(filePath, newContent);
  return true;
}

function callEmbeddedFeatures(params, options) {
  for (let embeddedFeature of _embeddedFeatures.embeddedFeatures) {
    const r = embeddedFeature.func(params, options);
    if (r) return r;
  }

  return undefined;
}

function doInprint(params, options) {
  if (options.embeddedFeatures === "first" || options.embeddedFeatures === true) {
    const r = callEmbeddedFeatures(params, options);
    if (r) return r;
  }

  if (options.inprint) {
    const r = options.inprint(params, options);
    if (r) return r;
  }

  if (options.embeddedFeatures === "last") {
    const r = callEmbeddedFeatures(params, options);
    if (r) return r;
  }

  return `// INPRINT_ERROR None of inprint functions returned a result. They all returned undefined!`;
}

function expectFeature(query0) {
  const query = query0.toLowerCase();

  for (let feature of _embeddedFeatures.embeddedFeatures) if (feature.name.toLowerCase() === query) return feature;

  for (let feature of _embeddedFeatures.embeddedFeatures) for (let keyword of feature.keywords) if (keyword.toLowerCase() === query) return feature;

  for (let feature of _embeddedFeatures.embeddedFeatures) if (feature.name.toLowerCase().includes(query)) return feature;

  for (let feature of _embeddedFeatures.embeddedFeatures) for (let keyword of feature.keywords) if (keyword.toLowerCase().includes(query)) return feature;

  throw new Error(`CODE00000000 No feature has ${query0} in name or keywords`);
} // const testFilePath = `D:\\b\\Mine\\GIT_Work\\yatasks_one_api\\src\\inprintTestFile.ts`;
// handleFile(testFilePath);


function run(options0) {
  if (process.argv[2] === "--version" || process.argv[2] === "-v") {
    // @ts-ignore
    console.log("1.2.11");
    return;
  } else if (process.argv[2] === "--help" || process.argv[2] === "-h" || process.argv[2] === "-help") {
    var _process$argv$;

    const featureQuery = ((_process$argv$ = process.argv[3]) === null || _process$argv$ === void 0 ? void 0 : _process$argv$.trim()) || "";

    if (featureQuery.length) {
      const feature = expectFeature(featureQuery);
      console.log(`${feature.name} usage help:\n`, feature.help);
    } else console.log(`
Usage:
inprint                     - Replaces all @INPRINT_START - @INPRINT_END blocks using functions specified in inprint.cjs
inprint [--help [feature]]  - prints help for specifiec 'feature'. 'feature' can be part of feature name or part of feature keyword
`);

    return;
  }

  let optionsPath = undefined;
  if (process.argv[2]) try {
    if (!options0) {
      optionsPath = process.argv[2];
      options0 = require(optionsPath);
    }
  } catch (e) {
    console.error(`CODE00000004 INPRINT failed to load '${optionsPath}' because of exception:`);
    console.error(e);
    process.exit(1);
    return;
  }

  try {
    if (!options0) {
      optionsPath = (0, _path.resolve)(process.cwd(), "inprint.cjs");
      options0 = require(optionsPath);
    }
  } catch (e) {
    if (e.code !== "MODULE_NOT_FOUND" || e.message.split("'")[1] !== optionsPath) {
      console.error(`CODE00000008 INPRINT failed to load '${optionsPath}' because of exception:`);
      console.error(e);
      process.exit(1);
      return;
    }
  }

  try {
    if (!options0) {
      optionsPath = (0, _path.resolve)(process.cwd(), "inprint.js");
      options0 = require(optionsPath);
    }
  } catch (e) {
    if (e.code !== "MODULE_NOT_FOUND" || e.message.split("'")[1] !== optionsPath) {
      console.error(`CODE00000009 INPRINT failed to load '${optionsPath}' because of exception:`);
      console.error(e);
      process.exit(1);
      return;
    }
  }

  if (!options0) optionsPath = "<default options>";

  const options = _objectSpread(_objectSpread({}, _InprintOptions.defaultInprintOptions), options0);

  let processedCount = 0;

  (async () => {
    if (options.logging) console.log(`CODE00000005 INPRINT options from ${optionsPath}`);
    const paths = await (0, _globby.default)(options.files);

    for (let filePath of paths) {
      if (options.logging === "files") console.log(`CODE00000006 INPRINT ${filePath}`);
      if (filePath.includes("node_modules") && options.skipNodeModules) continue;
      if (handleFile(filePath, options)) processedCount++;
    }

    if (options.logging) console.log(`CODE00000007 INPRINT finished, ${paths.length} - total files, ${processedCount} - processed, ${paths.length - processedCount} - skipped`);
    if (options.forceProcessTermination) process.exit(0);
  })();
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbnByaW50LnRzIl0sIm5hbWVzIjpbImlucHJpbnRfcHJlZml4Iiwic3RhcnRQcmVmaXgiLCJlbmRQcmVmaXgiLCJ1c2FnZU5vdGljZSIsIndyaXRlRmlsZVN5bmNJZkNoYW5nZWQiLCJmaWxlTmFtZSIsImNvbnRlbnQiLCJjdXJyZW50IiwiZSIsImhhbmRsZUZpbGUiLCJmaWxlUGF0aCIsIm9wdGlvbnMiLCJjb250ZW50U3RyIiwiaW5jbHVkZXMiLCJmaWxlSGVhZGVyIiwicGFydHMwIiwic3BsaXQiLCJwYXJ0cyIsImkiLCJsZW5ndGgiLCJzIiwic3RhcnRzV2l0aCIsImNvbnNvbGUiLCJlcnJvciIsImhlYWRlciIsIm1pZGRsZVBhcnRzIiwibGFzdFBhcnQiLCJwb3AiLCJwYXJhbXNTdHIiLCJzdWJzdHIiLCJ0cmltIiwibWlkZGxlIiwiam9pbiIsInRhaWwiLCJwYXJhbXMiLCJhYnNvbHV0ZVBhdGgiLCJKU09ONSIsInBhcnNlIiwicHVzaCIsIm5ld01pZGRsZSIsIm1lc3NhZ2UiLCJwYXJ0IiwiZG9JbnByaW50Iiwic3RhY2siLCJuZXdDb250ZW50IiwibWFwIiwicCIsInByZXR0aWVyT3B0cyIsImNhbGxFbWJlZGRlZEZlYXR1cmVzIiwiZW1iZWRkZWRGZWF0dXJlIiwiZW1iZWRkZWRGZWF0dXJlcyIsInIiLCJmdW5jIiwidW5kZWZpbmVkIiwiaW5wcmludCIsImV4cGVjdEZlYXR1cmUiLCJxdWVyeTAiLCJxdWVyeSIsInRvTG93ZXJDYXNlIiwiZmVhdHVyZSIsIm5hbWUiLCJrZXl3b3JkIiwia2V5d29yZHMiLCJFcnJvciIsInJ1biIsIm9wdGlvbnMwIiwicHJvY2VzcyIsImFyZ3YiLCJsb2ciLCJmZWF0dXJlUXVlcnkiLCJoZWxwIiwib3B0aW9uc1BhdGgiLCJyZXF1aXJlIiwiZXhpdCIsImN3ZCIsImNvZGUiLCJkZWZhdWx0SW5wcmludE9wdGlvbnMiLCJwcm9jZXNzZWRDb3VudCIsImxvZ2dpbmciLCJwYXRocyIsImZpbGVzIiwi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QzhDLEdBQVIsQ0FBYSxxQ0FBb0NHLFdBQVksRUFBN0Q7QUFDckIsVUFBTVEsS0FBSyxHQUFHLE1BQU0scUJBQU9wRSxPQUFPLENBQUNxRSxLQUFmLENBQXBCOztBQUVBLFNBQUssSUFBSXRFLFFBQVQsSUFBcUJxRSxLQUFyQixFQUE0QjtBQUN4QixVQUFJcEUsT0FBTyxDQUFDbUUsT0FBUixLQUFvQixPQUF4QixFQUFpQ3hELE9BQU8sQ0FBQzhDLEdBQVIsQ0FBYSx3QkFBdUIxRCxRQUFTLEVBQTdDO0FBQ2pDLFVBQUlBLFFBQVEsQ0FBQ0csUUFBVCxDQUFrQixjQUFsQixLQUFxQ0YsT0FBTyxDQUFDc0UsZUFBakQsRUFBa0U7QUFDbEUsVUFBSXhFLFVBQVUsQ0FBQ0MsUUFBRCxFQUFXQyxPQUFYLENBQWQsRUFBbUNrRSxjQUFjO0FBQ3BEOztBQUNELFFBQUlsRSxPQUFPLENBQUNtRSxPQUFaLEVBQ0l4RCxPQUFPLENBQUM4QyxHQUFSLENBQ0ssa0NBQWlDVyxLQUFLLENBQUM1RCxNQUFPLG1CQUFrQjBELGNBQWUsaUJBQzVFRSxLQUFLLENBQUM1RCxNQUFOLEdBQWUwRCxjQUNsQixZQUhMO0FBS0osUUFBSWxFLE9BQU8sQ0FBQ3VFLHVCQUFaLEVBQXFDaEIsT0FBTyxDQUFDTyxJQUFSLENBQWEsQ0FBYjtBQUN4QyxHQWhCRDtBQWlCSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBKU09ONSBmcm9tIFwianNvbjVcIjtcbmltcG9ydCBnbG9iYnkgZnJvbSBcImdsb2JieVwiO1xuaW1wb3J0IHsgcmVhZEZpbGVTeW5jLCB3cml0ZUZpbGVTeW5jIH0gZnJvbSBcImZzXCI7XG5pbXBvcnQgeyByZXNvbHZlIH0gZnJvbSBcInBhdGhcIjtcbmltcG9ydCB7IGVtYmVkZGVkRmVhdHVyZXMgfSBmcm9tIFwiLi9lbWJlZGRlZEZlYXR1cmVzXCI7XG5pbXBvcnQgeyBkZWZhdWx0SW5wcmludE9wdGlvbnMsIElucHJpbnRPcHRpb25zIH0gZnJvbSBcIi4vSW5wcmludE9wdGlvbnNcIjtcbmltcG9ydCB7IGZvcm1hdFR5cGVzY3JpcHQgfSBmcm9tIFwiLi9mb3JtYXRUeXBlc2NyaXB0XCI7XG5pbXBvcnQgeyBFbWJlZGRlZEZlYXR1cmUgfSBmcm9tIFwiLi9FbWJlZGRlZEZlYXR1cmVcIjtcblxuZXhwb3J0IGNvbnN0IGlucHJpbnRfcHJlZml4ID0gXCJAXCIgKyBcIklOUFJJTlRcIjtcbmV4cG9ydCBjb25zdCBzdGFydFByZWZpeCA9IFwiX1NUQVJUXCI7XG5leHBvcnQgY29uc3QgZW5kUHJlZml4ID0gXCJfRU5EXCI7XG5leHBvcnQgY29uc3QgdXNhZ2VOb3RpY2UgPSBgXG5VU0FHRTpcblxuLy8gJHtpbnByaW50X3ByZWZpeH1fU1RBUlQgey4uLmFueV9qc29uX3BhcmFtcy4uLn1cbi8vIEdlbmVyYXRlZCBjb2RlIHdpbGwgZ28gaGVyZVxuLy8gJHtpbnByaW50X3ByZWZpeH1fRU5EXG5gO1xuXG5pbnRlcmZhY2UgSW5wcmludEZpbGVQYXJ0IHtcbiAgICBoZWFkZXI6IHN0cmluZztcbiAgICBwYXJhbXM6IGFueTtcbiAgICBtaWRkbGU6IHN0cmluZztcbiAgICB0YWlsOiBzdHJpbmc7XG4gICAgbmV3TWlkZGxlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCB3cml0ZUZpbGVTeW5jSWZDaGFuZ2VkID0gKGZpbGVOYW1lOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZykgPT4ge1xuICAgIGxldCBjdXJyZW50OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY3VycmVudCA9IHJlYWRGaWxlU3luYyhmaWxlTmFtZSwgXCJ1dGYtOFwiKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgaWYgKGN1cnJlbnQgIT09IGNvbnRlbnQpIHtcbiAgICAgICAgd3JpdGVGaWxlU3luYyhmaWxlTmFtZSwgY29udGVudCwgXCJ1dGYtOFwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVGaWxlKGZpbGVQYXRoOiBzdHJpbmcsIG9wdGlvbnM6IElucHJpbnRPcHRpb25zKTogYm9vbGVhbiB7XG4gICAgY29uc3QgY29udGVudFN0ciA9IHJlYWRGaWxlU3luYyhmaWxlUGF0aCwgXCJ1dGYtOFwiKTtcblxuICAgIGlmICghY29udGVudFN0ci5pbmNsdWRlcyhpbnByaW50X3ByZWZpeCkpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IFtmaWxlSGVhZGVyLCAuLi5wYXJ0czBdID0gY29udGVudFN0ci5zcGxpdChpbnByaW50X3ByZWZpeCk7XG4gICAgY29uc3QgcGFydHM6IElucHJpbnRGaWxlUGFydFtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0czAubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgcyA9IHBhcnRzMFtpXTtcbiAgICAgICAgaWYgKCFzLnN0YXJ0c1dpdGgoc3RhcnRQcmVmaXgpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDT0RFMDAwMDAwMDEgSU5QUklOVF9FUlJPUiBObyAke2lucHJpbnRfcHJlZml4fSR7c3RhcnRQcmVmaXh9IGluICR7ZmlsZVBhdGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhcnRzMFtpICsgMV0uc3RhcnRzV2l0aChlbmRQcmVmaXgpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDT0RFMDAwMDAwMDIgSU5QUklOVF9FUlJPUiBObyAke2lucHJpbnRfcHJlZml4fSR7ZW5kUHJlZml4fSBpbiAke2ZpbGVQYXRofWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFtoZWFkZXIsIC4uLm1pZGRsZVBhcnRzXSA9IHMuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICBjb25zdCBsYXN0UGFydCA9IG1pZGRsZVBhcnRzLnBvcCgpO1xuXG4gICAgICAgICAgICBjb25zdCBwYXJhbXNTdHIgPSBoZWFkZXIuc3Vic3RyKHN0YXJ0UHJlZml4Lmxlbmd0aCkudHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgbWlkZGxlID0gbWlkZGxlUGFydHMuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBsYXN0UGFydCArIGlucHJpbnRfcHJlZml4ICsgcGFydHMwW2kgKyAxXTtcblxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG1pZGRsZSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVBhdGg6IGZpbGVQYXRoLFxuICAgICAgICAgICAgICAgIC4uLkpTT041LnBhcnNlKHBhcmFtc1N0ciksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGFydHMucHVzaCh7IGhlYWRlciwgcGFyYW1zLCBtaWRkbGUsIHRhaWwsIG5ld01pZGRsZTogXCJcIiB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ09ERTAwMDAwMDAzIElOUFJJTlRfRVJST1IgJHtlLm1lc3NhZ2V9IGluICR7ZmlsZVBhdGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXJ0Lm5ld01pZGRsZSA9IGRvSW5wcmludChwYXJ0LnBhcmFtcywgb3B0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHBhcnQubmV3TWlkZGxlID0gYC8vIElOUFJJTlRfRkFJTEVEIGJlY2F1c2Ugb2YgZXhjZXB0aW9uOlxcbiR7ZS5tZXNzYWdlIHx8IFwiTk9fRVJST1JfTUVTU0FHRVwifVxcXFxuJHtcbiAgICAgICAgICAgICAgICBlLnN0YWNrIHx8IFwiTk9fU1RBQ0tfVFJBQ0VcIlxuICAgICAgICAgICAgfWBcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCJcXG5cIilcbiAgICAgICAgICAgICAgICAuam9pbihcIlxcbi8vICAgICBcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBuZXdDb250ZW50ID0gZm9ybWF0VHlwZXNjcmlwdChcbiAgICAgICAgZmlsZUhlYWRlciArIGlucHJpbnRfcHJlZml4ICsgcGFydHMubWFwKChwKSA9PiBgJHtwLmhlYWRlcn1cXG4ke3AubmV3TWlkZGxlfVxcbiR7cC50YWlsfWApLmpvaW4oaW5wcmludF9wcmVmaXgpLFxuICAgICAgICBvcHRpb25zLnByZXR0aWVyT3B0c1xuICAgICk7XG4gICAgd3JpdGVGaWxlU3luY0lmQ2hhbmdlZChmaWxlUGF0aCwgbmV3Q29udGVudCk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsRW1iZWRkZWRGZWF0dXJlcyhwYXJhbXM6IGFueSwgb3B0aW9uczogSW5wcmludE9wdGlvbnMpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGZvciAobGV0IGVtYmVkZGVkRmVhdHVyZSBvZiBlbWJlZGRlZEZlYXR1cmVzKSB7XG4gICAgICAgIGNvbnN0IHIgPSBlbWJlZGRlZEZlYXR1cmUuZnVuYyhwYXJhbXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAocikgcmV0dXJuIHI7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkb0lucHJpbnQocGFyYW1zOiBhbnksIG9wdGlvbnM6IElucHJpbnRPcHRpb25zKTogc3RyaW5nIHtcbiAgICBpZiAob3B0aW9ucy5lbWJlZGRlZEZlYXR1cmVzID09PSBcImZpcnN0XCIgfHwgb3B0aW9ucy5lbWJlZGRlZEZlYXR1cmVzID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHIgPSBjYWxsRW1iZWRkZWRGZWF0dXJlcyhwYXJhbXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAocikgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5wcmludCkge1xuICAgICAgICBjb25zdCByID0gb3B0aW9ucy5pbnByaW50KHBhcmFtcywgb3B0aW9ucyk7XG4gICAgICAgIGlmIChyKSByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5lbWJlZGRlZEZlYXR1cmVzID09PSBcImxhc3RcIikge1xuICAgICAgICBjb25zdCByID0gY2FsbEVtYmVkZGVkRmVhdHVyZXMocGFyYW1zLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHIpIHJldHVybiByO1xuICAgIH1cbiAgICByZXR1cm4gYC8vIElOUFJJTlRfRVJST1IgTm9uZSBvZiBpbnByaW50IGZ1bmN0aW9ucyByZXR1cm5lZCBhIHJlc3VsdC4gVGhleSBhbGwgcmV0dXJuZWQgdW5kZWZpbmVkIWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBlY3RGZWF0dXJlKHF1ZXJ5MDogc3RyaW5nKTogRW1iZWRkZWRGZWF0dXJlIHtcbiAgICBjb25zdCBxdWVyeSA9IHF1ZXJ5MC50b0xvd2VyQ2FzZSgpO1xuICAgIGZvciAobGV0IGZlYXR1cmUgb2YgZW1iZWRkZWRGZWF0dXJlcykgaWYgKGZlYXR1cmUubmFtZS50b0xvd2VyQ2FzZSgpID09PSBxdWVyeSkgcmV0dXJuIGZlYXR1cmU7XG4gICAgZm9yIChsZXQgZmVhdHVyZSBvZiBlbWJlZGRlZEZlYXR1cmVzKVxuICAgICAgICBmb3IgKGxldCBrZXl3b3JkIG9mIGZlYXR1cmUua2V5d29yZHMpIGlmIChrZXl3b3JkLnRvTG93ZXJDYXNlKCkgPT09IHF1ZXJ5KSByZXR1cm4gZmVhdHVyZTtcbiAgICBmb3IgKGxldCBmZWF0dXJlIG9mIGVtYmVkZGVkRmVhdHVyZXMpIGlmIChmZWF0dXJlLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeSkpIHJldHVybiBmZWF0dXJlO1xuICAgIGZvciAobGV0IGZlYXR1cmUgb2YgZW1iZWRkZWRGZWF0dXJlcylcbiAgICAgICAgZm9yIChsZXQga2V5d29yZCBvZiBmZWF0dXJlLmtleXdvcmRzKSBpZiAoa2V5d29yZC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5KSkgcmV0dXJuIGZlYXR1cmU7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDT0RFMDAwMDAwMDAgTm8gZmVhdHVyZSBoYXMgJHtxdWVyeTB9IGluIG5hbWUgb3Iga2V5d29yZHNgKTtcbn1cblxuLy8gY29uc3QgdGVzdEZpbGVQYXRoID0gYEQ6XFxcXGJcXFxcTWluZVxcXFxHSVRfV29ya1xcXFx5YXRhc2tzX29uZV9hcGlcXFxcc3JjXFxcXGlucHJpbnRUZXN0RmlsZS50c2A7XG4vLyBoYW5kbGVGaWxlKHRlc3RGaWxlUGF0aCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBydW4ob3B0aW9uczA/OiBJbnByaW50T3B0aW9ucyB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcm9jZXNzLmFyZ3ZbMl0gPT09IFwiLS12ZXJzaW9uXCIgfHwgcHJvY2Vzcy5hcmd2WzJdID09PSBcIi12XCIpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zb2xlLmxvZyhfX1ZFUlNJT05fXyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJndlsyXSA9PT0gXCItLWhlbHBcIiB8fCBwcm9jZXNzLmFyZ3ZbMl0gPT09IFwiLWhcIiB8fCBwcm9jZXNzLmFyZ3ZbMl0gPT09IFwiLWhlbHBcIikge1xuICAgICAgICBjb25zdCBmZWF0dXJlUXVlcnkgPSBwcm9jZXNzLmFyZ3ZbM10/LnRyaW0oKSB8fCBcIlwiO1xuICAgICAgICBpZiAoZmVhdHVyZVF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZmVhdHVyZSA9IGV4cGVjdEZlYXR1cmUoZmVhdHVyZVF1ZXJ5KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke2ZlYXR1cmUubmFtZX0gdXNhZ2UgaGVscDpcXG5gLGZlYXR1cmUuaGVscCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgY29uc29sZS5sb2coYFxuVXNhZ2U6XG5pbnByaW50ICAgICAgICAgICAgICAgICAgICAgLSBSZXBsYWNlcyBhbGwgQElOUFJJTlRfU1RBUlQgLSBASU5QUklOVF9FTkQgYmxvY2tzIHVzaW5nIGZ1bmN0aW9ucyBzcGVjaWZpZWQgaW4gaW5wcmludC5janNcbmlucHJpbnQgWy0taGVscCBbZmVhdHVyZV1dICAtIHByaW50cyBoZWxwIGZvciBzcGVjaWZpZWMgJ2ZlYXR1cmUnLiAnZmVhdHVyZScgY2FuIGJlIHBhcnQgb2YgZmVhdHVyZSBuYW1lIG9yIHBhcnQgb2YgZmVhdHVyZSBrZXl3b3JkXG5gKTtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG9wdGlvbnNQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHByb2Nlc3MuYXJndlsyXSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghb3B0aW9uczApIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zUGF0aCA9IHByb2Nlc3MuYXJndlsyXTtcbiAgICAgICAgICAgICAgICBvcHRpb25zMCA9IHJlcXVpcmUob3B0aW9uc1BhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDT0RFMDAwMDAwMDQgSU5QUklOVCBmYWlsZWQgdG8gbG9hZCAnJHtvcHRpb25zUGF0aH0nIGJlY2F1c2Ugb2YgZXhjZXB0aW9uOmApO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFvcHRpb25zMCkge1xuICAgICAgICAgICAgb3B0aW9uc1BhdGggPSByZXNvbHZlKHByb2Nlc3MuY3dkKCksIFwiaW5wcmludC5janNcIik7XG4gICAgICAgICAgICBvcHRpb25zMCA9IHJlcXVpcmUob3B0aW9uc1BhdGgpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5jb2RlICE9PSBcIk1PRFVMRV9OT1RfRk9VTkRcIiB8fCBlLm1lc3NhZ2Uuc3BsaXQoXCInXCIpWzFdICE9PSBvcHRpb25zUGF0aCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ09ERTAwMDAwMDA4IElOUFJJTlQgZmFpbGVkIHRvIGxvYWQgJyR7b3B0aW9uc1BhdGh9JyBiZWNhdXNlIG9mIGV4Y2VwdGlvbjpgKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICBpZiAoIW9wdGlvbnMwKSB7XG4gICAgICAgICAgICBvcHRpb25zUGF0aCA9IHJlc29sdmUocHJvY2Vzcy5jd2QoKSwgXCJpbnByaW50LmpzXCIpO1xuICAgICAgICAgICAgb3B0aW9uczAgPSByZXF1aXJlKG9wdGlvbnNQYXRoKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUuY29kZSAhPT0gXCJNT0RVTEVfTk9UX0ZPVU5EXCIgfHwgZS5tZXNzYWdlLnNwbGl0KFwiJ1wiKVsxXSAhPT0gb3B0aW9uc1BhdGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENPREUwMDAwMDAwOSBJTlBSSU5UIGZhaWxlZCB0byBsb2FkICcke29wdGlvbnNQYXRofScgYmVjYXVzZSBvZiBleGNlcHRpb246YCk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zMCkgb3B0aW9uc1BhdGggPSBcIjxkZWZhdWx0IG9wdGlvbnM+XCI7XG5cbiAgICBjb25zdCBvcHRpb25zOiBJbnByaW50T3B0aW9ucyA9IHsgLi4uZGVmYXVsdElucHJpbnRPcHRpb25zLCAuLi5vcHRpb25zMCB9O1xuICAgIGxldCBwcm9jZXNzZWRDb3VudCA9IDA7XG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMubG9nZ2luZykgY29uc29sZS5sb2coYENPREUwMDAwMDAwNSBJTlBSSU5UIG9wdGlvbnMgZnJvbSAke29wdGlvbnNQYXRofWApO1xuICAgICAgICBjb25zdCBwYXRocyA9IGF3YWl0IGdsb2JieShvcHRpb25zLmZpbGVzKTtcblxuICAgICAgICBmb3IgKGxldCBmaWxlUGF0aCBvZiBwYXRocykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9nZ2luZyA9PT0gXCJmaWxlc1wiKSBjb25zb2xlLmxvZyhgQ09ERTAwMDAwMDA2IElOUFJJTlQgJHtmaWxlUGF0aH1gKTtcbiAgICAgICAgICAgIGlmIChmaWxlUGF0aC5pbmNsdWRlcyhcIm5vZGVfbW9kdWxlc1wiKSAmJiBvcHRpb25zLnNraXBOb2RlTW9kdWxlcykgY29udGludWU7XG4gICAgICAgICAgICBpZiAoaGFuZGxlRmlsZShmaWxlUGF0aCwgb3B0aW9ucykpIHByb2Nlc3NlZENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubG9nZ2luZylcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIGBDT0RFMDAwMDAwMDcgSU5QUklOVCBmaW5pc2hlZCwgJHtwYXRocy5sZW5ndGh9IC0gdG90YWwgZmlsZXMsICR7cHJvY2Vzc2VkQ291bnR9IC0gcHJvY2Vzc2VkLCAke1xuICAgICAgICAgICAgICAgICAgICBwYXRocy5sZW5ndGggLSBwcm9jZXNzZWRDb3VudFxuICAgICAgICAgICAgICAgIH0gLSBza2lwcGVkYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZm9yY2VQcm9jZXNzVGVybWluYXRpb24pIHByb2Nlc3MuZXhpdCgwKTtcbiAgICB9KSgpO1xufVxuIl19